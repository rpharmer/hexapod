# Hexapod

Control software for a hexapod robot split into three components:

- **`hexapod-server/`**: Linux host application that parses configuration and sends commands over serial.
- **`hexapod-client/`**: Firmware for a Raspberry Pi Pico + Pimoroni Servo 2040 board that drives servos and sensors.
- **`hexapod-common/`**: Shared protocol constants and serial interface abstractions used by both sides.

## Repository layout

```text
hexapod/
├── hexapod-common/
│   ├── include/hexapod-common.hpp
│   ├── protocol.md
│   └── makefile
├── hexapod-server/
│   ├── src/hexapod-server.cpp
│   ├── include/hexapod-server.hpp
│   ├── config.txt
│   └── makefile
└── hexapod-client/
    ├── hexapod-client.cpp
    ├── hexapod-client.hpp
    ├── CMakeLists.txt
    └── README.md
```

## How it currently works

1. The host (`hexapod-server`) loads calibration values from `config.txt` (TOML) and sorts them into servo order.
2. The host opens `/dev/ttyACM0` at 115200 baud and streams calibration pairs to the client firmware.
3. The firmware (`hexapod-client`) initializes hardware (servo cluster, LED bar, muxed ADC channels), applies calibration, and then listens for command bytes over USB serial.
4. Command handlers on firmware side apply servo values, toggle relay output, and return current/voltage/sensor/calibration values.

## Protocol snapshot

Protocol commands and byte values are defined in `hexapod-common/include/hexapod-common.hpp` and documented in `hexapod-common/protocol.md`.

Key command IDs:

- `SET_ANGLE_CALIBRATIONS (0x01)`
- `SET_TARGET_ANGLE (0x02)`
- `SET_POWER_RELAY (0x03)`
- `GET_ANGLE_CALIBRATIONS (0x04)`
- `GET_CURRENT (0x05)`
- `GET_VOLTAGE (0x06)`
- `GET_SENSOR (0x07)`

A handshake (`HELLO`, `ACK`, `NACK`) is documented in `protocol.md`, though host/server code appears focused on calibration transfer right now.

## Build and run

### Server (Linux)

Prerequisites:

- C++ compiler with C++17 support
- `CppLinuxSerial`
- `toml11`

Build:

```bash
cd hexapod-server
make
```

Run:

```bash
cd hexapod-server
./build/hexapod-server
```

> Note: the serial device path is currently hard-coded to `/dev/ttyACM0` in `src/hexapod-server.cpp`.

### Client firmware (Pico + Servo 2040)

Prerequisites:

- Pico SDK
- Pimoroni Pico libraries
- CMake 3.12+

Build:

```bash
cd hexapod-client
mkdir -p build
cd build
cmake ..
cmake --build .
```

Flash:

- Use the generated UF2 file, or
- Use the custom `program-pico` target generated by CMake when OpenOCD is configured.

## Current limitations / observations

- `hexapod-server/include/hexapod-server.hpp` is currently an empty placeholder.
- `hexapod-common/makefile` defines full library packaging, but there are no `src/*.cpp` files in that folder yet.
- The protocol document and implementation are partially out of sync (e.g., documented handshake and ACK/NACK framing vs direct command handling in code).
- `hexapod-client/CMakeLists.txt` includes an absolute include path to `hexapod-common` that may not be portable across machines.

## Suggested next steps

1. **Align protocol and implementation**
   - Implement and validate handshake/ACK/NACK framing on both host and firmware, or simplify `protocol.md` to match current behavior.
2. **Create a host command layer**
   - Replace one-off test logic in `hexapod-server.cpp` with reusable command functions (set angle, read voltage/current, etc.).
3. **Improve configuration and portability**
   - Move serial device path and baud rate into config/CLI flags.
   - Replace absolute include paths in firmware CMake with relative/project-configurable paths.
4. **Add tests**
   - Unit-test config parsing and servo calibration ordering on host side.
   - Add a host-side protocol simulator (or mock serial transport) to validate command serialization.
5. **Document hardware assumptions**
   - Add a wiring/pinout section and expected sensor indexing semantics to avoid ambiguity when deploying on new hardware.

## Safety notes

- Servo calibration values directly affect range of motion; validate limits before enabling full power.
- Use relay control commands with care and verify default fail-safe behavior on firmware startup.
